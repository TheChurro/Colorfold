use filters::Compute as ComputeShader;
use imaging::Image;
use std::collections::HashMap;

use serde::{Deserialize, Deserializer, Serialize, Serializer};

/**
 * Struct which holds the compute shading state
 */
pub struct FoldingMachine {
    stages: Vec<ComputeShader>,
    images: HashMap<String, Image>,
}

impl FoldingMachine {
    pub fn new(image_vec: Vec<(String, String)>, stages: Vec<ComputeShader>) -> FoldingMachine {
        let mut images = HashMap::new();
        for (name, location) in image_vec {
            images.insert(name.clone(), Image::new(name.clone(), location.clone()));
        }

        // TODO:Ensure that stages does not have any color sources outside of images
        FoldingMachine { stages, images }
    }

    pub fn from_map(images: HashMap<String, Image>, stages: Vec<ComputeShader>) -> FoldingMachine {
        // TODO:Ensure that stages does not have any color sources outside of images
        FoldingMachine { stages, images }
    }

    pub fn vdmx_shader(&mut self, stage: usize, save: bool) -> std::io::Result<String> {
        let stage = &self.stages[stage];

        // ========================================================================================
        // == Load images into memory and create the color loading string for the shader         ==
        // ========================================================================================
        let mut entry_string = String::from(
            "void main()
{
",
        );
        let mut shader_heading = String::from(
            "/*{
    \"DESCRIPTION\": \"An autogenerated shader by colorfold\",
    \"CREDIT\": \"generated by Colorfold\",
    \"ISFVSN\": \"2.0\",
    \"CATEGORIES\": [
    \"Generator\"
    ],
    \"INPUTS\": [
",
        );

        let img_sources = stage.get_required_sources();
        // Gather all images into their data arrays and check that all images have correct size.
        for (i, name) in img_sources.iter().enumerate() {
            // Create the shader string which loads the hsv vector for this image at a given pixel
            entry_string.push_str(
                format!(
                    "
  vec4 {name}_rgb = IMG_THIS_PIXEL({name}_img);
  float {name}_alpha = {name}_rgb.a;
  vec4 {name}_hsv = vec4(rgb2hsv({name}_rgb.xyz), 0);
  vec4 {name} = vec4(hsv2half_spherical({name}_hsv.xyz), 0);",
                    name = name
                )
                .as_str(),
            );
            if i > 0 {
                shader_heading.push_str(",\n");
            }
            shader_heading.push_str(
                format!(
                    "
        {{
            \"NAME\" : \"{name}_img\",
            \"TYPE\" : \"image\"
        }}",
                    name = name
                )
                .as_str(),
            );
        }

        shader_heading += "]}*/";

        // ========================================================================================
        // == Build the shader strings and the output line                                       ==
        // ========================================================================================

        let mut compute_shaders = stage.get_shader();
        let compute_call = compute_shaders.remove(0);
        let end_string = format!(
            "  // Convert the out_color back into rgb. Maintain alpha.
  vec3 color_out = vec3(hsv2rgb(half_spherical2hsv({compute}.xyz)));
  gl_FragColor = vec4(color_out, 1.0);
}}
",
            compute = compute_call
        );

        // Bind all compute functions with the main function
        let mut shading_str = entry_string + &end_string;
        for compute_shader in compute_shaders {
            shading_str = compute_shader + &shading_str;
        }
        let shader = shader_heading + &include_str!("../shaders/lib.fs") + &shading_str;
        if save {
            let out_name = stage.get_file();
            if let Some(image) = self.images.get(&out_name) {
                let out_image_file: String = image.location.clone();
                let last_period = out_image_file.rfind(".").unwrap_or(out_image_file.len());
                if let Some(segment) = out_image_file.get(0..last_period) {
                    std::fs::write(&format!("{}.fs", segment), &shader)?;
                }
            }
        }
        Ok(shader)
    }
}

// ================================================================================================
// == Serde Serialization for parsing input files.                                               ==
// ================================================================================================
#[derive(Serialize, Deserialize)]
struct SerializableFoldingMachine {
    stages: Vec<ComputeShader>,
    images: HashMap<String, Image>,
}

impl Serialize for FoldingMachine {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        SerializableFoldingMachine {
            stages: self.stages.clone(),
            images: self.images.clone(),
        }
        .serialize(serializer)
    }
}

impl<'de> Deserialize<'de> for FoldingMachine {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        Deserialize::deserialize(deserializer).map(
            |SerializableFoldingMachine { stages, images }| {
                FoldingMachine::from_map(images, stages)
            },
        )
    }
}
