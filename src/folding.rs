use data::DataSourceKind;
use dependency::DataDependencyGraph;
use filters::Compute as ComputeShader;
use std::path::PathBuf;

use serde::{Deserialize, Serialize};

/**
 * Struct which holds the compute shading state
 */
 #[derive(Serialize, Deserialize)]
pub struct FoldingMachine {
    stages: Vec<ComputeShader>,
    location: Option<PathBuf>
}

impl FoldingMachine {
    pub fn with_location(mut self, p: PathBuf) -> Self {
        self.location = Some(p);
        self
    }

    pub fn vdmx_shader(&mut self, stage: usize, save: bool) -> std::io::Result<String> {
        let stage = &self.stages[stage];

        // ========================================================================================
        // == Load images into memory and create the color loading string for the shader         ==
        // ========================================================================================
        let mut entry_string = String::from(
            "void main()
{
",
        );
        let mut shader_heading = String::from(
            "/".to_owned()
                + "*{
    \"DESCRIPTION\": \"An autogenerated shader by colorfold\",
    \"CREDIT\": \"generated by Colorfold\",
    \"ISFVSN\": \"2.0\",
    \"CATEGORIES\": [
    \"Generator\"
    ],
    \"INPUTS\": [
",
        );

        let mut img_sources = DataDependencyGraph::new();
        stage.get_required_sources(&mut img_sources);
        // Gather all images into their data arrays and check that all images have correct size.
        for (i, source) in img_sources.keys().enumerate() {
            if i > 0 {
                shader_heading.push_str(",\n");
            }

            match source.kind {
                DataSourceKind::Color => {
                    shader_heading += &format!(
                            "
            {{
                \"NAME\" : \"col_{name}_rgba\",
                \"LABEL\" : \"Color {name}\",
                \"TYPE\" : \"color\"
            }}",
                        name = source.name
                    );
                    entry_string.push_str(
                        format!(
                            "
      vec3 col_{name}_rgb = col_{name}_rgba.xyz;",
                            name = source.name
                        )
                        .as_str(),
                    );
                },
                DataSourceKind::Float => {
                    shader_heading += &format!(
                            "
            {{
                \"NAME\" : \"float_{name}\",
                \"LABEL\" : \"Float {name}\",
                \"TYPE\" : \"float\"
            }}",
                        name = source.name
                    );
                },
                DataSourceKind::Image => {
                    // Create the shader string which loads the hsv vector for this image at a given pixel
                    entry_string.push_str(
                        format!(
                            "
      vec3 img_{name}_rgb = IMG_THIS_PIXEL({name}_img).xyz;",
                            name = source.name
                        )
                        .as_str(),
                    );

                    shader_heading.push_str(
                        format!(
                            "
            {{
                \"NAME\" : \"{name}_img\",
                \"LABEL\" : \"Image {name}\",
                \"TYPE\" : \"image\"
            }}",
                            name = source.name
                        )
                        .as_str(),
                    );
                }
            }
        }

        shader_heading += "]}*/";

        // ========================================================================================
        // == Build the shader strings and the output line                                       ==
        // ========================================================================================

        let mut compute_shaders = stage.get_shader();
        let compute_call = compute_shaders.remove(0);
        let end_string = format!(
            "  // Convert the out_color back into rgb. Maintain alpha.
  vec3 color_out = vec3(hsv2rgb(half_spherical2hsv({compute}.xyz)));
  gl_FragColor = vec4(color_out, 1.0);
}}
",
            compute = compute_call
        );

        // Bind all compute functions with the main function
        let mut shading_str = entry_string + &end_string;
        for compute_shader in compute_shaders {
            shading_str = compute_shader + &shading_str;
        }
        let shader = shader_heading + &include_str!("../shaders/lib.fs") + &shading_str;
        if save {
            if let &Some(ref path) = &self.location {
                std::fs::write(path.with_extension("fs"), &shader)?;
            }
        }
        Ok(shader)
    }
}

// // ================================================================================================
// // == Serde Serialization for parsing input files.                                               ==
// // ================================================================================================
// #[derive(Serialize, Deserialize)]
// struct SerializableFoldingMachine {
//     stages: Vec<ComputeShader>,
//     images: HashMap<String, Image>,
// }
//
// impl Serialize for FoldingMachine {
//     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
//     where
//         S: Serializer,
//     {
//         SerializableFoldingMachine {
//             stages: self.stages.clone(),
//             images: self.images.clone(),
//         }
//         .serialize(serializer)
//     }
// }
//
// impl<'de> Deserialize<'de> for FoldingMachine {
//     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
//     where
//         D: Deserializer<'de>,
//     {
//         Deserialize::deserialize(deserializer).map(
//             |SerializableFoldingMachine { stages, images }| {
//                 FoldingMachine::from_map(images, stages)
//             },
//         )
//     }
// }
